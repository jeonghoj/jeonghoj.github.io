---
layout: post
title: "암호화 해시 알고리즘"
date: 2017-10-08 09:18
categories: web_study
---
## 암호화

특정한, 허가된 사람 이외에는 정보를 읽을 수 없도록 알고리즘을 이용하여 정보를 부호화하는 것이다.

여기서 정보를 부호화 하는 방식을 암호화 알고리즘이라고 한다.

보안이 뚫려 데이터가 탈취되었다 하더라도 데이터를 해독하지 못하게 함으로써 피해를 줄인다.

대한민국의 [정보통신망 이용촉진 및 정보보호 등에 관한 법률 제 28조](http://www.law.go.kr/%EB%B2%95%EB%A0%B9/%EC%A0%95%EB%B3%B4%ED%86%B5%EC%8B%A0%EB%A7%9D%EC%9D%B4%EC%9A%A9%EC%B4%89%EC%A7%84%EB%B0%8F%EC%A0%95%EB%B3%B4%EB%B3%B4%ED%98%B8%EB%93%B1%EC%97%90%EA%B4%80%ED%95%9C%EB%B2%95%EB%A5%A0/(20170726,14839,20170726)/%EC%A0%9C28%EC%A1%B0)에 의거하여 개인정보 즉 고유식별정보를 DB내에 저장할 경우 암호화를 필수적으로 해야만 한다.

### 암호화 알고리즘의 구분

* 키의 갯수
    >1 key (비밀키) : 대칭키
    >2 key (공개키) : 비대칭키
* 데이터의 처리 단위 : 스트림, 블록
* 원본 복호화 여부 : 단방향, 양방향

## 해시 함수(Hash function)

### 해시함수란

임의의 길이를 갖는 임의의 데이터에 대해 고정된 길이의 데이터로 매핑하는 함수를 말한다. Hash Table 자료구조에 사용되며, 빠른 데이터 검색을 할 수 있다.

암호학에서는 이러한 해시 함수의 특징에 **원래 입력값과 관계를 찾기 힘들다는 성질** 즉 입력값을 알 수 없다는 성질을 추가한 단반향성 암호화 해시 함수를 사용한다.

### 암호화 해시 함수(Cryptographic hash function)

암호화 해시 함수가 가져야 하는 성질은 다음과 같다.

* 역상 저항성(preimage resistance)

    주어진 해시 값을 생성하는 **입력값**을 찾는것이 계산상 어려워야 한다.

    >레인보우 어택 (Rainbow attack)
    >
    >역상 저항성을 우회하기 위해, 입력 값을 찾기 위한 무차별 대입(Brute-force attack)의 일종이다. 다양한 문자열을 조합하여 해시값을 계산한 Rainbow table을 이용하여 원본 문자열을 추출한다.
    >
    >입력 값에 임의의 값(Salt)를 추가하여 hash를 계산하면 방어할 수 있다.

* 2역상 저항성(second preimage resistance)

    주어진 입력 값에 대해 동일한 해시값을 갖는 입력값을 찾는것이 계산상 어려워야 한다.

    즉 입력값 hello를 알 경우 동일한 출력을 내는 입력값을 찾지 못하여야 한다.

* 충돌 저항성

    같은 해시 값을 생성하는 2개의 입력 값을 찾는 것이 계산상 어려워야 한다.

    해시 함수에서 서로 다른 두개의 입력값에 대해 동일한 출력값을 내는 상황을 해시 충돌이라 한다. 암호화 해시 함수의 경우 해시 함수의 안정성을 깨뜨리는 충돌 공격이 가능해질 수 있기 때문에, 의도적인 해시 충돌을 만들기 어렵도록 해야한다.

#### 암호화 해시 알고리즘 용도

* 원본 파일과 인터넷에서 받은 파일이 일치하는지 Checksum 확인
* 메시지 위변조 검출 및 **인증**을 위한 HMAC
* 메시지의 무결성 확인에 사용

## 단방향 암호화 해시 함수

단방향 해시 함수는 수학적인 연산을 통해 원본 메세지를 암호화된 메시지로 변환한다.

원본 메세지를 알면 암호화된 메시지(다이제스트)를 쉽게 구할 수 있지만, 다이제스트만으로는 원본 메세지를 쉽게 구할 수 없어야 한다.

이러한 특징을 "단방향성"이라고 한다.

사용자의 암호를 다이제스트로 변환하여 저장하고, 로그인 시 입력된 비밀번호를 변환한 다이제스트와 저장된 다이제스트의 일치 여부로 사용자를 인증한다.

## 단방향 암호화 해시 함수 문제점

### 인식 가능성

동일한 메세지에 대해 동일한 다이제스트를 가질 경우, 공격자가 사전에 메시지들을 변환한 다이제스트와 탈취한 다이제스트를 비교하여 원본 메세지를 찾아내거나 해시 충돌을 찾아낼 수 있다.

미리 변환해 놓은 다이제스트들을 레인보우 테이블이라고 하며 이를 이용한 공격을 레인보우 공격이라고 한다.

### 속도

해시 함수는 원래 짧은 시간으로 데이터를 검색하기 위해 설계된 것이다. 문제는 이러한 빠른 처리 속도 때문에 공격자는 매우 빠르게 다이제스트를 비교할 수 있다.

## 단방향 암호화 해시 함수 보완

### 솔팅

단방향 해시 함수에서 다이제스트를 생성할 때 추가하는 임의의 문자열을 salt라고 한다. 이 방법을 이용하면 해커가 만들어 놓은 레인보우 테이블이 대부분 무력화되어, 인식 가능성의 문제가 크게 줄어든다. 솔트와 패스워드를 모두 DB에 저장하고, 모든 패스워드가 고유의 솔트를 갖고 길이는 32비트 이상 되어야 안전하다.

### 키 스트레칭

입력한 패스워드의 다이제스트를 생성하고, 그 다이제스트를 입력 값으로 해서 또 다이제스트를 생성하는 방식으로써, 입력한 패스워드와 저장된 다이제스트 해싱횟수가 같아야 일치 여부를 확인할 수 있다. 또한 해시함수가 너무 빠르기 때문에 의도적으로 시간을 소요하게 로직을 짤 수 있어서 해커가 비밀번호의 입력값을 찾는데 충분히 오랜 시간을 걸리게 한다.

## PBKDF2

PBKDF2(Password-Based Key Derivation Function 2)는 RSA 연구소의 공개 키 암호화 표준(PKCS)의 #5 2.0 문서에 기술되어 있으며, 또한 IETF(Internet Engineering Task Force)에서 제공하는 인터넷 표준 문서 RFC 2898에 기술되어있다. 즉 암호화 해시 함수 표준이라는 소리다. 표준이기 때문에 널리 쓰여지고 있다.

PBKDF2는 다음과 같은 입력을 받는다.

PRF = 난수

Password = 입력한 암호

Salt = 다이제스트 생성시 추가하는 임의의 문자열

c = 해시 함수 반복 횟수

dkLen = 원하는 다이제스트 길이

그리고 출력값으로 DK(derived key)를 받는다.

## bcrypt

bcrypt란 Blowfish 알고리즘을 기반으로 설계한 암호화 해시 알고리즘이다. 비밀번호를 저장하기 위한 목적으로 개발되었으며, 지금까지 사용되고 있다. 이 알고리즘은 입력값을 72byte로 제한한다는 것이 흠이다. 이는 128byte를 맞추기 위함인데, 이러한 제약을 벗어나기 위해 나중에 개발된 script를 대안으로 사용하기도 한다.

### bcrypt 해싱 분석

ex) $2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy

앞의 4byte, $2a$는 이것이 bcrypt 알고리즘을 이용한 다이제스트라고 명시한다.

다음 10$은 Cost를 의미한다. bcrypt는 2^(cost)번 반복하여 만들어졌다고 명시한다.

다음 N9qo8uLOickgx2ZMRZoMye(22byte)는 이 bcrypt에 사용된 salt를 의미한다. salt는 128bit를 base64 인코딩하여 22개의 문자열을 갖는다.

그 이후 끝까지 IjZAgcfl7p92ldGxad68LJZdL17lhWy(31byte)는 해시 결과값이다.

따라서 salt값을 따로 저장할 필요없이 DB에는 총 128byte의 해시 문자열을 저장한다.

## scrypt

scrypt는 Colin Percival이 만들었으며, Tarsnap이라는 온라인 백업 서비스에서 사용되고 있었다. 2016년에 RFC 7914로 표준화되었다. 이 알고리즘을 간소화 한 버전은 전자화폐에서 이용되고있다.

PBKDF2와의 차이점이라면, PBKDF2는 가벼운 알고리즘으로써 모든 기기에 구현 가능하다는 장점이 있지만, 이 장점이 역으로 공격자가 가볍게 수백, 수천개의 병렬 연산으로 무차별 대입 공격을 가능하게 할 수 있다는 점이다.

그에 비해 scrypt는 역으로 알고리즘이 많은 자원을 요구하며, PBKDF2보다 상대적으로 많은 메모리 용량을 요구함으로써, 공격자가 병렬 연산을 어렵게 한다.

## 워드프레스에서의 암호 저장

워드프레스는 암호를 저장할 때 그대로 저장하지 않고 bcrypt 암호화 해시 함수를 이용하고 있다.

해시 함수를 이용하여 암호를 해싱하여 저장하는데, 그냥 단순히 해시 함수를 이용하여 저장하게 되면 앞서 말한 것처럼 레인보우 어택, 즉 무차별 대입 공격에 취약하게 된다.

때문에 패스워드에 문자열을 추가하는 솔팅 과정을 하게 된다. 이에 그치지 않고 그 결과값(Digest)를 입력값으로 하여 또 해싱 과정을 거친다. 워드프레스를 조사한 결과 워드프레스는 기본적으로 8코스트, 즉 2^8 번 동안이러한 과정을 반복하고 있다.

그러나 2^8번의 반복만으로는 컴퓨팅 기술이 많이 발전하였기 떄문에 저 값을 최소 16 이상으로 올려줘야 한다.

참고로 PBKDF2는 처음엔 200번 반복이었다가 현재 권장 반복 횟수를 10만번정도를 권장하고 있다.

친절하게도 wordpress의 pluggable.php파일을 통해 bcrypt의 cost를 쉽게 바꿀 수 있고, 플러그인으로 만들어 배포할 수 있다.

## 워드프레스 암호 저장 보완

### bcrypt 사용

wordpress가 저장된 폴더의 wp-includes/pluggable.php파일을 수정해준다.

[원본 소스](https://github.com/WordPress/WordPress/blob/master/wp-includes/pluggable.php) line 1886 new PasswordHash(8, true)의 8을 다른 숫자로 바꾸어준다. 이 8은 bcrypt의 cost를 의미한다.

워드프레스의 보안을 개선해주는 플러그인들을 사용해도 좋다. 그 플러그인들은 대부분 pluggable.php의 bcrypt 알고리즘 cost를 수정해 놓은 것들이다.

### scrypt 사용

scrypt는 최신의 암호화 해시 함수로써, 아직 native로 많이 사용되지 않는다. 따라서 php에서 scrypt를 사용할 수 있게 [phel](https://pecl.php.net/package/scrypt)에서 받아도 좋고, yum install scrypt를 이용해도 좋다. 그러고 나서 [enscrypt](https://wordpress.org/plugins/enscrypt/) 플러그인을 통해 scrypt를 wordpress에 적용 시킬 수 있다.

[참고 PPT](https://www.slideshare.net/ssuser800974/ss-76664853)